<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>自习室直播 - 专注时刻</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Pangolin&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&display=swap');

        /* 1. 基础布局 */
        body {
            background-color: transparent;
            /* OBS 透明背景 */
            margin: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* 2. 缩放容器 */
        #scaler-container {
            width: 900px;
            height: 550px;
            display: flex;
            flex-direction: column;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            /* Changed from center to flex-start */
            padding-top: 60px;
            /* Add top padding */
            align-items: center;
            transform-origin: center center;
            position: relative;
            /* For Checkmark positioning */
        }

        /* 3. 动画包装器 */
        #content-wrapper {
            width: 100%;
            position: relative;
            /* Ensure absolute children (badge) position correctly */
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0;
            /* 默认隐藏，等待数据 */
            filter: blur(0px);
            transition: opacity 0.5s ease;
        }

        #content-wrapper.active {
            opacity: 1;
        }

        /* 擦除动画 */
        @keyframes erase-effect {
            0% {
                -webkit-mask-position: 100% 0;
                mask-position: 100% 0;
                filter: blur(0px);
                opacity: 1;
            }

            50% {
                filter: blur(4px);
            }

            100% {
                -webkit-mask-position: 0% 0;
                mask-position: 0% 0;
                filter: blur(8px);
                opacity: 0;
            }
        }

        /* 重写动画 */
        @keyframes rewrite-effect {
            0% {
                opacity: 0;
                filter: blur(10px);
                transform: scale(0.98);
            }

            100% {
                opacity: 1;
                filter: blur(0px);
                transform: scale(1);
            }
        }

        .state-erasing {
            -webkit-mask-image: linear-gradient(to right, transparent 50%, black 55%);
            mask-image: linear-gradient(to right, transparent 50%, black 55%);
            -webkit-mask-size: 250% 100%;
            mask-size: 250% 100%;
            animation: erase-effect 1.2s forwards cubic-bezier(0.25, 1, 0.5, 1);
        }

        .state-writing {
            animation: rewrite-effect 0.8s forwards ease-out;
        }

        /* --- 粉笔风格样式 --- */
        .chalk-style {
            font-family: 'Pangolin', 'ZCOOL KuaiLe', "Comic Sans MS", "Chalkboard SE", "YouYuan", "幼圆", sans-serif;
            color: #ffffee;
            filter: url(#chalk-filter);
            line-height: 1.3;
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.2);
        }

        .chalk-header-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            width: 100%;
            text-align: center;
        }

        .chalk-text-item {
            font-size: 60px;
            font-weight: bold;
            white-space: nowrap;
        }

        .chalk-progress-bar {
            width: 90%;
            height: 24px;
            border: 4px solid #ffffee;
            border-radius: 12px;
            padding: 3px;
            box-sizing: border-box;
            filter: url(#chalk-filter);
            position: relative;
        }

        .chalk-progress-fill {
            height: 100%;
            background-color: #ffffee;
            border-radius: 8px;
            width: var(--progress-percent, 0%);
            transition: width 1s cubic-bezier(0.25, 1, 0.5, 1);
        }

        /* Finish State: Green Progress Bar */
        .chalk-progress-fill.finished {
            background-color: #72fb99;
            /* Light Green */
            transition: background-color 0.5s ease;
        }

        /* Resting State: Blue Progress Bar */
        .chalk-progress-fill.resting {
            background-color: #64b5f6;
            /* Light Blue */
            transition: background-color 0.5s ease;
        }

        /* Infinite Mode: Stripes or Breathing */
        .chalk-progress-fill.infinite-mode {
            background-color: #ffffee;
            background-image: repeating-linear-gradient(45deg,
                    transparent,
                    transparent 10px,
                    rgba(0, 0, 0, 0.1) 10px,
                    rgba(0, 0, 0, 0.1) 20px);
            width: 100% !important;
            /* Always full width */
            animation: infinite-slide 2s linear infinite;
        }

        @keyframes infinite-slide {
            0% {
                background-position: 0 0;
            }

            100% {
                background-position: 50px 0;
            }
        }

        /* Multi-Round Badge */
        .chalk-round-badge {
            position: absolute;
            right: 15px;
            /* Adjust based on bar width (90%) */
            top: 140px;
            /* Adjust vertically to align with bar */
            /* Using top relative to content-wrapper might be fragile, but effective. 
               Bar is roughly: Header (60px + gap) ... 
               Let's try absolute positioning relative to the wrapper center?
            */
            top: 50%;
            /* Center vertically first */
            transform: translateY(-50%) rotate(15deg);

            font-family: 'Pangolin', 'ZCOOL KuaiLe', sans-serif;
            color: #ffdd44;
            /* Yellowish */
            font-size: 36px;
            font-weight: bold;
            filter: url(#chalk-filter);
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.3);
            z-index: 5;
            white-space: nowrap;
        }

        .chalk-footer-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
        }

        .chalk-data-text {
            font-size: 60px;
            font-weight: normal;
        }

        .empty-state {
            font-size: 40px;
            opacity: 0.8;
        }

        /* --- Checkmark Animation --- */
        #checkmark-overlay {
            position: absolute;
            /* Position near the progress bar (which is 90% wide, centered) */
            /* Progress bar ends at: 50% + 45% = 95% from left, minus some padding */
            top: 50px;
            /* Align with content-wrapper top area */
            right: 5%;
            /* Align with progress bar right edge (100% - 90%)/2 = 5% */
            display: flex;
            justify-content: flex-end;
            align-items: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 10;
        }

        #checkmark-overlay.visible {
            opacity: 1;
        }

        .checkmark-svg {
            width: 120px;
            height: 120px;
            transform: rotate(-15deg) translateX(-20px);
            /* Shift left slightly to not overflow */
            filter: drop-shadow(0px 0px 5px rgba(255, 100, 100, 0.8));
        }

        .checkmark-path {
            fill: none;
            stroke: #ff4444;
            /* Chalk Red */
            stroke-width: 15;
            stroke-linecap: round;
            stroke-linejoin: round;
            stroke-dasharray: 1000;
            stroke-dashoffset: 1000;
            /* filter: url(#chalk-filter); Use chalk filter on stroke too? Maybe too heavy */
        }

        .animate-checkmark {
            animation: draw-check 1.5s ease-out forwards;
        }

        @keyframes draw-check {
            0% {
                stroke-dashoffset: 1000;
            }

            100% {
                stroke-dashoffset: 0;
            }
        }

        .svg-hidden {
            position: absolute;
            width: 0;
            height: 0;
            overflow: hidden;
        }

        /* --- Empty State / Sleeping Cat --- */
        #empty-state-wrapper {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -60%);
            /* Slightly higher for visual balance */
            display: none;
            /* Initially hidden */
            flex-direction: column;
            align-items: center;
            opacity: 0;
            transition: opacity 0.8s ease;
        }

        #empty-state-wrapper.visible {
            display: flex;
            opacity: 1;
        }

        /* Animations from reference, adapted for Chalk */
        @keyframes breathe {

            0%,
            100% {
                transform: scale(1) translateY(0);
            }

            50% {
                transform: scale(1.02) translateY(-2px);
            }
        }

        @keyframes tail-twitch {

            0%,
            90%,
            100% {
                transform: rotate(0deg);
            }

            92% {
                transform: rotate(5deg);
            }

            94% {
                transform: rotate(-5deg);
            }

            96% {
                transform: rotate(3deg);
            }
        }

        @keyframes float-z {
            0% {
                transform: translate(0, 0) scale(0.5);
                opacity: 0;
            }

            20% {
                opacity: 1;
                transform: translate(10px, -20px) scale(1);
            }

            80% {
                opacity: 0.8;
            }

            100% {
                transform: translate(25px, -60px) scale(1.2);
                opacity: 0;
            }
        }

        .cat-svg-container {
            width: 300px;
            height: 300px;
            filter: url(#chalk-filter);
            /* Apply Chalk Filter */
        }

        .cat-path {
            fill: none;
            stroke: #ffffee;
            stroke-width: 3;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .cat-body-group {
            transform-origin: center bottom;
            animation: breathe 5s ease-in-out infinite;
        }

        .cat-tail {
            transform-origin: 20px 130px;
            animation: tail-twitch 10s ease-in-out infinite;
        }

        .zzz {
            font-family: 'Pangolin', "Comic Sans MS", "Chalkboard SE", sans-serif;
            fill: #ffffee;
            font-weight: bold;
            opacity: 0;
        }

        .zzz-1 {
            animation: float-z 4s ease-out infinite 0s;
        }

        .zzz-2 {
            animation: float-z 4s ease-out infinite 1.3s;
        }

        .zzz-3 {
            animation: float-z 4s ease-out infinite 1s;
        }

        .empty-text {
            font-family: 'Pangolin', 'ZCOOL KuaiLe', "Comic Sans MS", "Chalkboard SE", "YouYuan", "幼圆", sans-serif;
            color: #ffffee;
            font-size: 60px;
            margin-top: 20px;
            filter: url(#chalk-filter);
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.2);
            text-align: center;
        }

        /* --- Reading Book (Middle Decoration) --- */
        #reading-book-container {
            position: absolute;
            bottom: 160px;
            /* Positioned above the footer */
            width: 100%;
            height: 110px;
            /* Fixed height for the gap */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1;
            opacity: 0.9;
        }

        .rc-svg {
            height: 100%;
            width: auto;
            filter: url(#chalk-filter);
        }

        .rc-line {
            fill: none;
            stroke: #ffffee;
            stroke-width: 3;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .rc-line-fill {
            fill: none;
            /* Chalk style usually outlines, but if needed, use transparency or hatching */
            stroke: #ffffee;
            stroke-width: 3;
            stroke-linecap: round;
            stroke-linejoin: round;
        }





        .rc-flipping-page {
            transform-origin: 400px 280px;
            fill: none;
            /* No white paper fill for chalk style */
            stroke: #ffffee;
            stroke-width: 3;
            animation: rc-flipPage 2.5s cubic-bezier(0.645, 0.045, 0.355, 1) infinite;
        }

        .rc-p1 {
            animation-delay: 0s;
        }

        .rc-p2 {
            animation-delay: 0s;
        }

        .rc-p3 {
            animation-delay: 0s;
        }



        @keyframes rc-flipPage {
            0% {
                transform: perspective(1000px) rotateY(0deg);
                opacity: 1;
            }

            15% {
                transform: perspective(1000px) rotateY(10deg);
            }

            85% {
                opacity: 1;
            }

            100% {
                transform: perspective(1000px) rotateY(-180deg);
                opacity: 0;
            }
        }

        /* Footer Carousel Styles */
        .hint-msg {
            position: absolute;
            width: 100%;
            top: 0;
            left: 0;
            opacity: 0;
            transition: opacity 1s ease, transform 1s ease;
            transform: translateY(20px);
        }

        .hint-msg.active {
            opacity: 1;
            transform: translateY(0);
        }
    </style>
</head>

<body>

    <div id="scaler-container">
        <!-- 正常内容显示区 -->
        <div id="content-wrapper">
            <div class="chalk-header-group chalk-style">
                <span style="color: darkturquoise;" class="chalk-text-item" id="user-name">Loading...</span>
                <span class="chalk-text-item">正在专注</span>
                <span style="color:darksalmon;" class="chalk-text-item" id="project-name">...</span>
            </div>

            <div class="chalk-progress-bar">
                <div class="chalk-progress-fill"></div>
            </div>

            <div class="chalk-footer-group chalk-style">
                <span class="chalk-data-text" id="current-time-info">进度: 0/0</span>
                <span class="chalk-data-text">|</span>
                <span class="chalk-data-text" id="daily-total-info">当日: 0m</span>
            </div>
        </div>

        <!-- Reading Book Decoration (Bottom Middle) -->
        <div id="reading-book-container">
            <!-- Modified viewBox to center the book (Spine is at x=400, so 400 - 390/2 = 205) -->
            <svg class="rc-svg" viewBox="205 170 390 185" preserveAspectRatio="xMidYMid meet"
                xmlns="http://www.w3.org/2000/svg">

                <g id="rc-book" transform="translate(0, 10)">
                    <!-- Book Base -->
                    <path class="rc-line-fill" d="M300,340 L500,340 L530,310 L330,310 Z" style="fill:none" />
                    <path class="rc-line-fill" d="M300,335 L400,335 L400,220 L300,220 Z" />
                    <path class="rc-line-fill" d="M500,335 L400,335 L400,220 L500,220 Z" />
                    <!-- Spine -->
                    <line x1="400" y1="220" x2="400" y2="340" class="rc-line" stroke-width="4" />
                    <!-- Flipping Pages -->
                    <g id="rc-flipping-pages">
                        <path class="rc-flipping-page rc-p1" d="M400,335 L500,335 L500,220 L400,220 Z" />
                        <path class="rc-flipping-page rc-p2" d="M400,335 L500,335 L500,220 L400,220 Z" />
                        <path class="rc-flipping-page rc-p3" d="M400,335 L500,335 L500,220 L400,220 Z" />
                    </g>
                </g>
            </svg>
        </div>

        <!-- 空闲状态：睡觉猫咪 -->
        <div id="empty-state-wrapper">
            <div class="empty-text">大家都在休息呢...</div>
            <div class="cat-svg-container">
                <svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg" class="w-full h-full">
                    <defs>
                        <!-- Mask to hide body lines behind head -->
                        <mask id="head-mask">
                            <rect width="100%" height="100%" fill="white" />
                            <!-- Head Shapes filled with Black to Hide -->
                            <g transform="translate(120, 115)">
                                <circle cx="0" cy="0" r="32" fill="black" />
                                <path d="M -25 -15 L -35 -40 L -5 -25 Z" fill="black" />
                                <path d="M 25 -15 L 35 -40 L 5 -25 Z" fill="black" />
                            </g>
                        </mask>
                    </defs>

                    <!-- Body Group with Breathing and Masking -->
                    <g class="cat-body-group" mask="url(#head-mask)">
                        <!-- Tail -->
                        <path d="M 40 140 Q 10 140 15 110 Q 20 80 50 100" class="cat-path cat-tail" />
                        <!-- Body -->
                        <path d="M 50 140 C 30 140, 30 90, 80 90 C 120 90, 150 110, 150 140 C 150 170, 70 170, 50 140"
                            class="cat-path" />
                        <!-- Front Paw -->
                        <!-- 前爪 (搭在前面) -->
                        <ellipse cx="90" cy="145" rx="12" ry="8" class="cat-path" />
                        <path d="M 85 145 L 95 145" class="cat-path" />
                    </g>

                    <!-- Head Group (No Mask)-->
                    <g transform="translate(120, 115)">
                        <!-- Ears -->
                        <path d="M -25 -15 L -35 -40 L -5 -25 Z" class="cat-path" />
                        <path d="M 25 -15 L 35 -40 L 5 -25 Z" class="cat-path" />
                        <path d="M -25 -15 L -32 -32 L -10 -22 Z" class="cat-path" /> <!-- 内耳 -->
                        <path d="M 25 -15 L 32 -32 L 10 -22 Z" class="cat-path" />

                        <!-- Face Outline (Partial circle to leave room for ears if needed, but simple circle is fine for chalk)-->
                        <circle cx="0" cy="0" r="32" class="cat-path" />

                        <!-- Eyes (Closed Curves)-->
                        <path d="M -18 -2 Q -12 -8 -6 -2" class="cat-path" stroke-width="2.5" />
                        <path d="M 6 -2 Q 12 -8 18 -2" class="cat-path" stroke-width="2.5" />

                        <!-- Nose -->
                        <path d="M -3 6 L 3 6 L 0 9 Z" class="cat-path" fill="none" />

                        <!-- Mouth -->
                        <path d="M -3 9 Q -5 12 0 12 Q 5 12 3 9" class="cat-path" />

                        <!-- Whiskers -->
                        <g stroke="#ffffee" stroke-width="1" opacity="0.7">
                            <line x1="-20" y1="5" x2="-35" y2="2" />
                            <line x1="-20" y1="10" x2="-36" y2="10" />
                            <line x1="20" y1="5" x2="35" y2="2" />
                            <line x1="20" y1="10" x2="36" y2="10" />
                        </g>


                    </g>

                    <!-- Zzz Group -->
                    <g transform="translate(120, 100)">
                        <text x="0" y="0" font-size="28" class="zzz zzz-1">Z</text>
                        <text x="0" y="-15" font-size="22" class="zzz zzz-2">Z</text>
                        <text x="0" y="-30" font-size="18" class="zzz zzz-3">z</text>
                    </g>
                </svg>
            </div>

        </div>

        <!-- 红色对勾叠加层 -->
        <div id="checkmark-overlay">
            <svg class="checkmark-svg" viewBox="0 0 200 200">
                <path class="checkmark-path" d="M40 100 L80 140 L160 60" />
            </svg>
        </div>

        <!-- 常驻底部提示 -->
        <div id="hint-footer" class="chalk-style"
            style="position: absolute; bottom: 10px; font-size: 50px; opacity: 0.8; width: 100%; text-align: center;">
            <div style="color: red; font-size: 60px; font-weight: bold;">弹幕发送(空格分隔)</div>
            <div id="hint-carousel" style="font-size: 60px; height: 60px; margin-bottom: 10px; position: relative;">
                <div class="hint-msg active">"结束打卡" 休息 | "打卡 项目" 正计时</div>
                <div class="hint-msg">"打卡 项目 分钟数 x次" 多次番茄钟</div>
                <div class="hint-msg">"AI报告"&"专注统计"查看报告</div>
            </div>
        </div>
    </div>

    <!-- SVG 滤镜定义 -->
    <svg class="svg-hidden">
        <defs>
            <filter id="chalk-filter" x="-20%" y="-20%" width="140%" height="140%" color-interpolation-filters="sRGB">
                <feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="3" result="noise" />
                <feDisplacementMap in="SourceGraphic" in2="noise" scale="3" xChannelSelector="R" yChannelSelector="G"
                    result="displacedText" />
                <feComposite in="displacedText" in2="noise" operator="arithmetic" k1="0" k2="1.0" k3="-0.5" k4="0.2"
                    result="grainyText" />
                <feGaussianBlur in="SourceGraphic" stdDeviation="1.2" result="glow" />
                <feMerge>
                    <feMergeNode in="glow" />
                    <feMergeNode in="grainyText" />
                </feMerge>
            </filter>
        </defs>
    </svg>

    <script>
        // --- 核心状态 ---
        let userList = [];
        let currentIndex = 0;
        let ws = null;
        let reconnectTimer = null;
        let carouselTimer = null;
        let heartbeatTimer = null; // New heartbeat
        let carouselInterval = 15000; // Default
        let breakDuration = 300; // Default 5 mins (seconds)

        // 锁定状态：当有人完成时，锁定轮播，展示动画
        let isLocked = false;

        // --- DOM 元素 ---
        const containerWrapper = document.getElementById('content-wrapper');
        const emptyWrapper = document.getElementById('empty-state-wrapper');
        const containerDiv = document.getElementById('scaler-container');
        const elUser = document.getElementById('user-name');
        const elProject = document.getElementById('project-name');
        const elCurrentInfo = document.getElementById('current-time-info');
        const elDailyInfo = document.getElementById('daily-total-info');
        const fillBar = document.querySelector('.chalk-progress-fill');

        // New Badge Element
        const elRoundBadge = document.createElement('div');
        elRoundBadge.className = 'chalk-round-badge';
        elRoundBadge.style.display = 'none';
        // Insert badge after progress bar (we'll adjust CSS to position it)
        document.querySelector('.chalk-progress-bar').parentNode.insertBefore(elRoundBadge, document.querySelector('.chalk-progress-bar').nextSibling);


        const checkOverlay = document.getElementById('checkmark-overlay');
        const checkPath = document.querySelector('.checkmark-path');
        const bookContainer = document.getElementById('reading-book-container'); // Book animation container

        // --- WebSocket 连接 ---
        function connect() {
            ws = new WebSocket('ws://localhost:23335');

            ws.onopen = () => {
                console.log('Connected to local server');
                if (reconnectTimer) clearInterval(reconnectTimer);
            };

            ws.onmessage = (event) => {
                try {
                    const msg = JSON.parse(event.data);
                    if (msg.type === 'STATE_UPDATE') {
                        // 如果处于锁定状态（正在播完成动画），暂不更新列表显示，只更新数据
                        // 但如果列表空了，还是要更新的
                        handleStateUpdate(msg.data.list);
                    } else if (msg.type === 'SESSION_COMPLETE') {
                        // 收到完成事件，触发高光时刻
                        playFinishAnimation(msg.data);
                    }
                } catch (e) {
                    console.error('Parse error:', e);
                }
            };

            ws.onclose = () => {
                console.log('Disconnected, retrying in 3s...');
                reconnectTimer = setTimeout(connect, 3000);
            };
        }

        function handleStateUpdate(newList) {
            const wasEmpty = userList.length === 0;
            userList = newList;
            const isEmpty = userList.length === 0;

            // Debug: Print received list (user can check browser console)
            console.log("State Update Received:", newList);

            if (isEmpty) {
                // 如果空了，隐藏内容，显示空状态
                containerWrapper.style.display = 'none';
                containerWrapper.classList.remove('active');
                if (bookContainer) bookContainer.style.display = 'none'; // Hide book too

                // 只有当没有显示过空状态时才 fade-in，避免闪烁
                if (!emptyWrapper.classList.contains('visible')) {
                    emptyWrapper.style.display = 'flex';
                    // Small delay to allow display flex to apply before opacity transition
                    requestAnimationFrame(() => {
                        emptyWrapper.classList.add('visible');
                    });
                }
                return;
            } else {
                // 有人了，隐藏空状态
                if (emptyWrapper.classList.contains('visible')) {
                    emptyWrapper.classList.remove('visible');
                    setTimeout(() => {
                        emptyWrapper.style.display = 'none';
                    }, 500); // Wait for fade out
                }

                containerWrapper.style.display = 'flex';
                if (bookContainer) bookContainer.style.display = 'flex'; // Show book too
            }

            // 如果锁定中，不切人，只更新当前人的数据（如果还在列表里）
            if (isLocked) return;

            // 如果之前是空的，或者刚初始化，立刻渲染
            if (wasEmpty) {
                currentIndex = 0;
                renderCurrentUser(false);
                containerWrapper.classList.add('active');
            }
        }

        // --- 初始化 ---
        connect();

        // 启动本地 Heartbeat，每秒刷新 UI 进度
        heartbeatTimer = setInterval(() => {
            // 只有当有用户时才刷新
            if (userList.length > 0 && !isLocked) {
                renderCurrentUser(false); // animate=false prevents re-triggering entrance animations
            }
        }, 1000);

        // 启动轮播定时器
        startCarousel();

        function startCarousel() {
            if (carouselTimer) clearInterval(carouselTimer);
            carouselTimer = setInterval(() => {
                if (userList.length > 1 && !isLocked) {
                    nextUser();
                }
            }, carouselInterval);
        }

        function nextUser() {
            currentIndex++;
            if (currentIndex >= userList.length) currentIndex = 0;
            renderCurrentUser(true); // animate=true triggers transition
        }

        // --- Hint Carousel Logic ---
        const hintMsgs = document.querySelectorAll('.hint-msg');
        let hintIndex = 0;
        setInterval(() => {
            hintMsgs[hintIndex].classList.remove('active');
            hintIndex = (hintIndex + 1) % hintMsgs.length;
            hintMsgs[hintIndex].classList.add('active');
        }, 5000); // Switch every 5 seconds

        // --- 渲染逻辑 ---
        function renderCurrentUser(animate = true) {
            if (userList.length === 0) return;

            if (currentIndex >= userList.length) currentIndex = 0;
            const data = userList[currentIndex];

            // --- 核心修复: 本地实时计算进度 ---
            const now = Date.now();
            let elapsedSec = 0;
            // 状态判断
            const isResting = data.status === 'resting';

            if (isResting) {
                const start = data.restStartTime || now;
                elapsedSec = Math.max(0, Math.floor((now - start) / 1000));
            } else {
                elapsedSec = Math.max(0, Math.floor((now - data.startTime) / 1000));
            }

            // 计算今日总时长
            const todayTotalRaw = data.todayTotal || 0;
            let realDailyTotal = todayTotalRaw;
            if (!isResting) {
                const backendDuration = data.duration || 0;
                realDailyTotal = todayTotalRaw + Math.max(0, elapsedSec - backendDuration);
            }

            // Define UI Update Logic
            const applyToUI = () => {
                elUser.textContent = data.username;

                // Project Name
                if (isResting) {
                    elProject.textContent = "休息中... ☕";
                } else {
                    elProject.textContent = data.project;
                }

                // Infinite vs Normal Logic
                const isInfinite = data.targetDuration < 0;

                if (isInfinite && !isResting) {
                    // Infinite Mode
                    const hours = Math.floor(elapsedSec / 3600);
                    const mins = Math.floor((elapsedSec % 3600) / 60);
                    const secs = elapsedSec % 60;

                    let timeStr = `${mins}m ${secs}s`;
                    if (hours > 0) timeStr = `${hours}h ${mins}m`;

                    elCurrentInfo.textContent = `已专注: ${timeStr}`;

                    // Progress Bar for Infinite (Stripes)
                    fillBar.style.width = '100%';
                    if (!fillBar.classList.contains('infinite-mode')) {
                        fillBar.classList.add('infinite-mode');
                        fillBar.classList.remove('finished', 'resting');
                    }
                } else {
                    // Normal or Resting
                    fillBar.classList.remove('infinite-mode');

                    const targetSec = isResting ? breakDuration : data.targetDuration;

                    // Progress Calculation
                    let percent = 0;
                    if (targetSec > 0) percent = (elapsedSec / targetSec) * 100;
                    percent = Math.min(100, Math.max(0, percent));

                    fillBar.style.width = percent + '%';

                    // Text Info
                    const currentMins = Math.floor(elapsedSec / 60);
                    const targetMins = Math.floor(targetSec / 60);

                    if (isResting) {
                        const remaining = Math.max(0, targetSec - elapsedSec);
                        const rMins = Math.floor(remaining / 60);
                        const rSecs = remaining % 60;
                        elCurrentInfo.textContent = `休息: ${rMins}m ${rSecs}s`;

                        if (!fillBar.classList.contains('resting')) fillBar.classList.add('resting');
                        fillBar.classList.remove('finished');
                    } else {
                        // Studying
                        elCurrentInfo.textContent = `进度: ${currentMins}/${targetMins}m`;

                        if (percent >= 100) {
                            fillBar.classList.add('finished');
                            fillBar.classList.remove('resting');
                        } else {
                            fillBar.classList.remove('finished', 'resting');
                        }
                    }

                    // Checkmark
                    if (!isResting && percent >= 100) {
                        if (!checkOverlay.classList.contains('visible')) {
                            checkOverlay.classList.add('visible');
                            checkPath.style.animation = 'none';
                            checkPath.offsetHeight;
                            checkPath.style.animation = 'draw-check 1.5s ease-out forwards';
                        }
                    } else {
                        checkOverlay.classList.remove('visible');
                    }
                }

                // Daily Total
                const dailyMins = Math.floor(realDailyTotal / 60);
                elDailyInfo.textContent = `今日: ${dailyMins}m`;

                // Badge Logic
                if (data.totalRounds > 1) {
                    elRoundBadge.style.display = 'block';
                    const remaining = data.totalRounds - data.currentRound;
                    if (remaining > 0) {
                        elRoundBadge.textContent = `×${remaining}`;
                    } else {
                        elRoundBadge.style.display = 'none';
                    }
                } else {
                    elRoundBadge.style.display = 'none';
                }
            };

            // 1. 切换动效 (Animate Switch)
            if (animate) {
                containerWrapper.classList.remove("state-writing");
                containerWrapper.classList.add("state-erasing");

                setTimeout(() => {
                    applyToUI(); // Update Content while hidden/blurred

                    // Reset Bar Transition immediately to prevent sliding from old value
                    fillBar.style.transition = 'none';
                    containerDiv.style.setProperty('--progress-percent', '0%'); // Legacy?
                    void fillBar.offsetWidth; // Force Reflow

                    containerWrapper.classList.remove("state-erasing");
                    containerWrapper.classList.add("state-writing");

                    // Re-enable transition
                    setTimeout(() => {
                        fillBar.style.transition = 'width 1s cubic-bezier(0.25, 1, 0.5, 1)';
                    }, 50);

                }, 1200);
            }
            // 2. 仅更新数据 (Heartbeat update)
            else {
                applyToUI();
            }
        }

        function updateUIContent(data, isResting, current, target, daily) {
            elUser.textContent = data.username;

            if (isResting) {
                elProject.textContent = "休息中... ☕";
                elCurrentInfo.textContent = `休息: ${current} / ${target}分`;
            } else {
                elProject.textContent = data.project;
                elCurrentInfo.textContent = `进度: ${current} / ${target}分`;
            }

            elDailyInfo.textContent = `当日: ${daily}分钟`;
        }

        function updateProgressBar(currentSec, targetSec) {
            let percent = (currentSec / targetSec) * 100;
            if (percent > 100) percent = 100; // Cap at 100
            containerDiv.style.setProperty('--progress-percent', percent + '%');
        }

        // --- 高光时刻动画 ---
        function playFinishAnimation(finishedUser) {
            // 1. 找到该用户在列表中的位置
            const idx = userList.findIndex(u => u.username === finishedUser.username);
            if (idx !== -1) {
                currentIndex = idx; // 强行切到这个用户
            }

            console.log("播放完成动画:", finishedUser.username);
            isLocked = true; // 锁定轮播

            // 立即渲染该用户（带切换动画，确保画面是他）
            renderCurrentUser(true);

            // 等切换动画做完 (约1.5s)，开始打勾
            setTimeout(() => {
                // 进度条变绿
                fillBar.classList.add('finished');
                containerDiv.style.setProperty('--progress-percent', '100%');

                // 显示对勾
                checkOverlay.classList.add('visible');
                checkPath.classList.add('animate-checkmark');

                // 20秒后解锁
                setTimeout(() => {
                    isLocked = false;
                    checkOverlay.classList.remove('visible');
                    checkPath.classList.remove('animate-checkmark');
                    fillBar.classList.remove('finished');

                    // 此时后端应该已经把他踢了，前端下一次轮播或更新会自动切走
                    nextUser();

                }, 20000); // 20s展示期

            }, 1500);
        }

        // --- 轮播控制 ---
        function nextUser() {
            if (isLocked) return; // 锁定中不轮播
            if (userList.length <= 1) return;

            currentIndex = (currentIndex + 1) % userList.length;
            renderCurrentUser(true);
        }

        // --- 定时器 ---
        // 实时计时 (每秒微调UI)
        setInterval(() => {
            if (userList.length === 0 || isLocked) return;
            renderCurrentUser(false); // 仅刷新数字
        }, 1000);

        // 轮播控制 (Dynamic Interval)
        async function startCarousel() {
            try {
                const res = await fetch('/api/config');
                const data = await res.json();
                if (data.displayDuration && data.displayDuration.index) {
                    carouselInterval = data.displayDuration.index;
                }
                if (data.multiSession && data.multiSession.breakDuration) {
                    breakDuration = data.multiSession.breakDuration / 1000; // ms to s
                }
            } catch (e) {
                console.warn("Config Load Error", e);
            }

            console.log(`[Index] Carousel Interval: ${carouselInterval}ms, Break: ${breakDuration}s`);

            setInterval(() => {
                if (userList.length > 1) {
                    nextUser();
                }
            }, carouselInterval);
        }

        // --- 自动缩放 ---
        function autoScale() {
            const container = document.getElementById('scaler-container');
            const scale = Math.min(window.innerWidth / 900, window.innerHeight / 550) * 0.95;
            container.style.transform = `scale(${scale})`;
        }
        window.addEventListener('load', () => {
            autoScale();
            connect();
            startCarousel();
        });
        window.addEventListener('resize', autoScale);

    </script>
</body>

</html>